# AI-AGENTIC CURSOR CONTEXT
# This project is maintained and edited primarily by LLMs.
# All code must be optimized for LLM readability, editability, and refactorability.

---

## ‚ö†Ô∏è CRITICAL: ARCHITECTURAL PITFALLS PREVENTION

**MANDATORY READING**: Before making ANY significant architectural changes, code refactoring, or major feature additions, you MUST consult `ARCHITECTURAL_PITFALLS_GUIDE.md`.

**This guide documents REAL disasters that occurred in this project:**
- God Object Catastrophe (661-line files)
- Global State Contamination 
- Mixed Responsibility Violations
- Framework Coupling Disasters
- Type System Chaos
- Constants Scatter Catastrophe

**Prevention Protocol**:
1. **Read the pitfalls guide** before major changes
2. **Apply the prevention checklists** during development
3. **Follow the enforcement rules** to avoid regression
4. **Use the success metrics** to validate architectural quality

**Remember**: These pitfalls caused 40% development overhead and required massive refactoring. Prevention is critical.

---

## üéØ CRITICAL: ONE SOURCE OF TRUTH FOR GENERATORS

**MANDATORY COMPLIANCE**: There must be exactly ONE dish generation entry point per nation. This is ESSENTIAL for multi-nation expansion.

**CURRENT ARCHITECTURE - DO NOT VIOLATE**:
- **FrameworkCoreDishGenerator**: Framework-agnostic base class (NEVER nation-specific)
- **AirNomadDishGenerator**: Single Air Nomad entry point via `createDish()` method
- **Support Modules**: Pure functions only (prose, cleanup, metadata) - NO dish creation capability

**FORBIDDEN PATTERNS**:
‚ùå Multiple generator classes per nation (e.g., AirNomadMainDishGenerator, AirNomadSideDishGenerator)
‚ùå Direct dish creation in support modules (e.g., ProseComposer.createDish())
‚ùå Duplicate framework implementations (e.g., CoreDishGenerator - already removed)
‚ùå Cross-layer imports (Support modules importing generators)

**MANDATORY READING**: `ONE_SOURCE_OF_TRUTH_GENERATOR.md` before adding ANY new generator functionality.

**Critical for Multi-Nation Expansion**: When adding Water Tribe, Earth Kingdom, or Fire Nation - follow the exact pattern of AirNomadDishGenerator extending FrameworkCoreDishGenerator with a single createDish() method.

---

### GENERAL PRINCIPLES

- Treat the LLM as the primary developer, not a human.
- Code must be immediately parseable without external context.
- Redundancy is good. Cleverness is bad. Semantic clarity is king.
- Favor structural explicitness over aesthetic conciseness.

---

### FILE STRUCTURE

- No file should exceed 500 lines or ~6,000 characters.
- Each file should represent **one clear concept or domain unit**.
- Do not create monolithic "utils" or "index" hubs unless absolutely necessary.
- Group related files into domain-based folders, not generic categories.
- **ACTIVE MONITORING**: See `FILE_SIZE_MONITOR.md` for live compliance tracking.

---

### TYPESCRIPT PRACTICES

- Prefer `type` aliases over `interface` unless extending external libs.
- **Convert interfaces to types wherever appropriate.**
- Avoid deeply nested generics, conditional types, or infer statements.
- Types should reflect **semantic meaning**, not implementation structure.
- Don't try to outsmart the LLM with complex type gymnastics.

---

### FUNCTION DESIGN

- Functions must be named in `verbNoun` form: `loadUser`, `fetchReport`, `sendEmail`.
- **Rename all functions to follow verbNoun conventions.**
- Do not use acronyms, abbreviations, or vague terms in function names.
- Functions should accept at most 3‚Äì4 parameters‚Äîprefer object destructuring for clarity.
- Always declare return shapes explicitly with named types.
- Default to pure functions. If side effects occur, name should indicate it (`logAndSend()`).

---

### NAMING & SEMANTICS

- Names must be human-readable and semantically rich for AI interpretation.
- Type names should clearly indicate domain and context: `UserPayload`, `CartItemConfig`.
- Avoid single-letter variables or generic names like `data`, `item`, `result` unless context is tight.
- **Extract all "magic values" into named constants.**

---

### COMMENTS & DOCBLOCKS

- **Add comprehensive doc comments to all exports.**
- Every exported function or type must be preceded by a **purpose-first** doc comment.
- Comments should emphasize **intent**, not implementation steps.
- Use comments to **anchor meaning** near complex conditionals or transformations.
- AI must be able to reconstruct the "why" behind code from surrounding comments.

---

### MODULES & DEPENDENCIES

- Never use circular imports.
- Avoid star imports (`import * as X`) unless you're re-exporting a well-defined module surface.
- Side-effect imports are forbidden‚Äîeverything must be explicit.
- Code must respect strict dependency layering: higher-level modules must not import from lower layers.

---

### LLM EDITABILITY GUARANTEES

- Code must be self-sufficient and semantically chunkable by the LLM.
- Break complex tasks into small named functions with doc comments.
- Avoid magic values‚Äîdeclare them with names so LLMs can reason about them.
- Always tag hacks, shortcuts, or temporary solutions with `// FIXME:` or `// TEMP:` and a reason.
- Never inline deeply abstract logic‚Äîbreak it into its own function even if it feels verbose.

---

### ERROR HANDLING

- **Improve error handling with contextual messages.**
- Do not use empty `catch` blocks‚Äîalways log or rethrow with context.
- Errors must be actionable or explainable. AI must know why the code failed.
- Use error boundaries where applicable in UI contexts.

---

### GOAL

Every code file should act as a **self-contained, intention-labeled semantic block** that an LLM can:
1. Understand at a glance,
2. Modify without context leaks,
3. Refactor without introducing regressions.

If it's not explainable in a single pass by an AI, rewrite it until it is.

---

### FILE SIZE COMPLIANCE MONITORING

**MANDATORY**: Update `FILE_SIZE_MONITOR.md` with every response that modifies code files.

**Protocol**:
1. Check line counts of any modified files
2. Log violations immediately in the monitor document
3. Plan modularization for any file approaching 500 lines
4. Maintain perfect LLM-first compliance across entire codebase

**Current Status**: ‚úÖ ALL FILES COMPLIANT (as of 2025-01-19)
