# AI-AGENTIC CURSOR CONTEXT
# This project is maintained and edited primarily by LLMs.
# All code must be optimized for LLM readability, editability, and refactorability.

---

## ⚠️ CRITICAL: ARCHITECTURAL PITFALLS PREVENTION

**MANDATORY READING**: Before making ANY significant architectural changes, code refactoring, or major feature additions, you MUST consult `docs/ARCHITECTURAL_PITFALLS_GUIDE.md`.

**This guide documents REAL disasters that occurred in this project:**
- God Object Catastrophe (661-line files)
- Global State Contamination 
- Mixed Responsibility Violations
- Framework Coupling Disasters
- Type System Chaos
- Constants Scatter Catastrophe
- UI/UX Design Degradation & Theme System Failures
- Content Generation Disconnect & Naming Incoherence

**Prevention Protocol**:
1. **Read the pitfalls guide** before major changes
2. **Apply the prevention checklists** during development
3. **Follow the enforcement rules** to avoid regression
4. **Use the success metrics** to validate architectural quality

**Remember**: These pitfalls caused 40% development overhead and required massive refactoring. Prevention is critical.

---

## 🎯 CRITICAL: SOVEREIGN ARCHITECTURE COMPLIANCE

**MANDATORY**: This project uses **TRUE SOVEREIGN ARCHITECTURE** - there is exactly ONE generator that handles ALL nations through data injection.

**CURRENT ARCHITECTURE - DO NOT VIOLATE**:
```typescript
// THE SOVEREIGN GENERATOR (the only place with generation logic)
export class SovereignDishGenerator {
  createDish(config: GeneratorConfig): GeneratedAirNomadDish {
    // ALL dish creation logic for ALL nations lives here
    // Nations provide data through config, NEVER logic
  }
}

// PURE DATA PROVIDERS (zero logic, data only)
export const AirNomadDataProvider = {
  forMainCourse: () => createAirNomadConfiguration('main_course'),
  forSideDish: () => createAirNomadConfiguration('side_dish'),
  forCeremonialOffering: () => createAirNomadConfiguration('ceremonial_offering')
};

// USAGE PATTERN (same for ALL nations)
const sovereign = new SovereignDishGenerator();
const dish = sovereign.createDish(AirNomadDataProvider.forMainCourse());
```

**FORBIDDEN PATTERNS**:
❌ Nation-specific generator classes (e.g., AirNomadDishGenerator) - use compatibility adapter only
❌ Generation logic in data providers - they must be pure data
❌ Multiple sovereign generators - there is exactly ONE
❌ Nation-specific logic in the sovereign generator - use data injection

**MANDATORY READING**: `docs/ONE_SOURCE_OF_TRUTH_GENERATOR.md` for complete architectural understanding.

**Multi-Nation Template**: Each new nation follows identical pattern with {Nation}DataProvider providing pure data to the single SovereignDishGenerator.

---

## 🎨 CRITICAL: UI/UX SYSTEM ARCHITECTURE

**CURRENT UI SYSTEMS - MAINTAIN CONSISTENCY**:

### **Floating Theme System**
```css
.theme-icon {
  position: fixed; top: 20px; right: 20px;  /* Tiny floating corner control */
  width: 40px; height: 40px;                /* Minimal space usage */
  z-index: 1000;                            /* Always accessible */
}
```

### **Four-Nation Theme Architecture**
```typescript
// Complete theme coverage with canonical Avatar colors:
'air-nomads':   { primary: '#FF9500', accent: '#FFC107' },  // Orange/Gold (monk robes)
'water-tribe':  { primary: '#0288D1', accent: '#03A9F4' },  // Deep ocean blue
'earth-kingdom': { primary: '#388E3C', accent: '#66BB6A' }, // Forest green
'fire-nation':  { primary: '#D32F2F', accent: '#FF5722' }   // Crimson/Fire red
```

### **5-Second Loading Animation System**
```typescript
// Immersive Air Nomad cooking journey:
Phase 1: 🌿 "Gathering sacred ingredients..." (spinning)
Phase 2: 🔥 "Invoking ancient cooking techniques..." (floating)  
Phase 3: 🧂 "Balancing flavors with temple spices..." (bouncing)
Phase 4: 🍽️ "Arranging with ceremonial precision..." (pulsing)
Phase 5: ✨ "Blessing the sacred meal..." (shaking)
```

**UI ENFORCEMENT RULES**:
1. **Visual Hierarchy**: Primary actions prominent, secondary controls minimized
2. **Cultural Authenticity**: Use canonical Avatar nation colors only
3. **Accessibility Compliance**: WCAG 4.5:1+ contrast ratios required
4. **Professional Polish**: No amateur emoji elements, use proper graphics
5. **Floating Controls**: Non-essential controls float, don't consume layout space

---

## 🏷️ CRITICAL: INTELLIGENT NAME GENERATION SYSTEM

**CURRENT NAMING ARCHITECTURE - MAINTAIN ACCURACY**:

### **Ingredient-Aware Naming Requirements**
```typescript
// CORRECT: Names must reflect actual dish ingredients
Ingredients: [Pine Nuts (Rare), Noodles (Common), Carrot (Common)]
Generated Name: "Pine Nut Noodles"  ✅ Features the rare ingredient

// FORBIDDEN: Generic names ignoring ingredients  
Generated Name: "Noodles"  ❌ Ignores Pine Nuts completely
Generated Name: "Bowl"     ❌ No ingredient information
```

### **Smart Ingredient Selection Algorithm**
```typescript
function selectFeaturedIngredients(ingredients: AirNomadIngredient[]): AirNomadIngredient[] {
  // 1. Prioritize by rarity: legendary > rare > uncommon > common
  // 2. Identify distinctive characteristics: nuts, mushrooms, fruits, spices
  // 3. Select 1-2 most interesting ingredients for naming
  // 4. Ensure featured ingredients represent unique dish character
}
```

**NAMING ENFORCEMENT RULES**:
1. **Ingredient Inclusion Mandate**: Every dish name MUST reference actual ingredients
2. **Rarity Prioritization**: Rare/legendary ingredients featured prominently 
3. **Avatar Style Compliance**: Follow canonical patterns like "Sea Prune Stew"
4. **Specificity Over Mysticism**: Prefer "Pine Nut Soup" over "Sacred Wind Bowl"
5. **Descriptive Value**: Names must convey what's actually in the dish

---

### GENERAL PRINCIPLES

- Treat the LLM as the primary developer, not a human.
- Code must be immediately parseable without external context.
- Redundancy is good. Cleverness is bad. Semantic clarity is king.
- Favor structural explicitness over aesthetic conciseness.

---

### FILE STRUCTURE

- No file should exceed 500 lines or ~6,000 characters.
- Each file should represent **one clear concept or domain unit**.
- Do not create monolithic "utils" or "index" hubs unless absolutely necessary.
- Group related files into domain-based folders, not generic categories.

**CURRENT MODULE STRUCTURE**:
```
src/
├── types/
│   ├── core-interfaces.ts            # Universal base types for all nations
│   └── types.ts                      # Air Nomad type extensions
├── generator/
│   ├── sovereign-dish-generator.ts   # THE sovereign generator (ALL logic)
│   ├── air-nomad-compatibility-adapter.ts # Backward compatibility only
│   ├── name-composer.ts              # Intelligent ingredient-aware naming
│   ├── prose-composer.ts             # Description & lore generation
│   ├── text-cleanup.ts               # Pure text processing
│   └── domain-specific-cleanup.ts    # Air Nomad cultural logic
├── data/
│   ├── air-nomad-data-provider.ts    # Pure Air Nomad data (zero logic)
│   ├── shared-constants.ts           # Centralized cultural data
│   └── air-nomad/                    # Air Nomad specific data
└── ui/
    ├── dish-display.ts               # UI rendering and interaction
    ├── loading-animation.ts          # 5-second Air Nomad cooking journey
    ├── theme-manager.ts              # Four-nation theme system
    └── emoji-renderer.ts             # Intelligent emoji enhancement
```

---

### TYPESCRIPT PRACTICES

- Prefer `type` aliases over `interface` unless extending external libs.
- **Convert interfaces to types wherever appropriate.**
- Avoid deeply nested generics, conditional types, or infer statements.
- Types should reflect **semantic meaning**, not implementation structure.
- Don't try to outsmart the LLM with complex type gymnastics.

---

### FUNCTION DESIGN

- Functions must be named in `verbNoun` form: `loadUser`, `fetchReport`, `sendEmail`.
- **Rename all functions to follow verbNoun conventions.**
- Do not use acronyms, abbreviations, or vague terms in function names.
- Functions should accept at most 3–4 parameters—prefer object destructuring for clarity.
- Always declare return shapes explicitly with named types.
- Default to pure functions. If side effects occur, name should indicate it (`logAndSend()`).

---

### NAMING & SEMANTICS

- Names must be human-readable and semantically rich for AI interpretation.
- Type names should clearly indicate domain and context: `UserPayload`, `CartItemConfig`.
- Avoid single-letter variables or generic names like `data`, `item`, `result` unless context is tight.
- **Extract all "magic values" into named constants.**

**SEMANTIC MODULE NAMING RULES**:
- `SovereignDishGenerator` - Obviously THE main generator
- `{Nation}DataProvider` - Obviously provides data, not logic
- `{feature}-compatibility-adapter.ts` - Obviously deprecated/temporary
- `.forMainCourse()` - Obviously for main course dishes (vs generic `.mainCourse()`)

---

### COMMENTS & DOCBLOCKS

- **Add comprehensive doc comments to all exports.**
- Every exported function or type must be preceded by a **purpose-first** doc comment.
- Comments should emphasize **intent**, not implementation steps.
- Use comments to **anchor meaning** near complex conditionals or transformations.
- AI must be able to reconstruct the "why" behind code from surrounding comments.

---

### MODULES & DEPENDENCIES

- Never use circular imports.
- Avoid star imports (`import * as X`) unless you're re-exporting a well-defined module surface.
- Side-effect imports are forbidden—everything must be explicit.
- Code must respect strict dependency layering: higher-level modules must not import from lower layers.
- **Use relative imports for production compatibility** (e.g., `'../generator/sovereign-dish-generator.js'`)

---

### LLM EDITABILITY GUARANTEES

- Code must be self-sufficient and semantically chunkable by the LLM.
- Break complex tasks into small named functions with doc comments.
- Avoid magic values—declare them with names so LLMs can reason about them.
- Always tag hacks, shortcuts, or temporary solutions with `// FIXME:` or `// TEMP:` and a reason.
- Never inline deeply abstract logic—break it into its own function even if it feels verbose.

---

### ERROR HANDLING

- **Improve error handling with contextual messages.**
- Do not use empty `catch` blocks—always log or rethrow with context.
- Errors must be actionable or explainable. AI must know why the code failed.
- Use error boundaries where applicable in UI contexts.

---

### GOAL

Every code file should act as a **self-contained, intention-labeled semantic block** that an LLM can:
1. Understand at a glance,
2. Modify without context leaks,
3. Refactor without introducing regressions.

If it's not explainable in a single pass by an AI, rewrite it until it is.

---

### CURRENT QUALITY STATUS

**Architectural Excellence**: 95-97/100 + UI/UX Excellence + Name Generation Intelligence
- ✅ **Sovereign Architecture**: Perfect single-source-of-truth generator system
- ✅ **UI/UX System**: Professional floating controls, four-nation themes, loading animations
- ✅ **Intelligent Naming**: 100% ingredient-aware name generation with rarity prioritization
- ✅ **LLM Editability**: All files under 500 lines, semantic clarity, comprehensive documentation
- ✅ **TypeScript Compliance**: Clean compilation, proper module resolution
- ✅ **Cultural Authenticity**: Canonical Avatar colors, authentic ingredient systems
